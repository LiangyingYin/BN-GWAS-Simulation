#***************************************************************************************************
# Aim of this function is to perform the univariate test
#***************************************************************************************************
# @ - gene_index: index of genes in the simulated causal network
# @ - samples_data: samples with raw gene expression data
# @ - samples_data_iptg: samples with imputed gene expression data
#***************************************************************************************************
Univariate_Test<-function(gene_index,samples_data,samples_data_iptg)
{
  outcome = samples_data[,dim(samples_data)[2]] # phenotype or outcome is the last column in this sample matrix
  
  
  univariate_test_Matrix = matrix(nrow = length(gene_index), ncol = 5)
  
  count = 1
  for(gene in gene_index)
  {
    print(gene)
    gene_rowdata = samples_data[,gene]
    gene_imputedata = samples_data_iptg[,gene]
    
    lm_gene_rowdata = lm(outcome~gene_rowdata)
    lm_gene_imputedata = lm(outcome~gene_imputedata)
    
    lm_gene_rowdata_pval = summary(lm_gene_rowdata)$coefficients[2,4]
    lm_gene_imputedata_pval = summary(lm_gene_imputedata)$coefficients[2,4]
      
       # univariate_test_Matrix[count,1] = gene # write gene_index into this column 
    univariate_test_Matrix[count,1] = count
    univariate_test_Matrix[count,2] = unname(coefficients(lm_gene_rowdata)[2])
    univariate_test_Matrix[count,3] = unname(coefficients(lm_gene_imputedata)[2])
    univariate_test_Matrix[count,4] = lm_gene_rowdata_pval
    univariate_test_Matrix[count,5] = lm_gene_imputedata_pval
    
    count = count + 1
  }
  return(univariate_test_Matrix)
}



#***************************************************************************************************
# Aim of this function is to perform the univariate test
# With more return items, including r.square generated by univariate test
#***************************************************************************************************
# @ - gene_index: index of genes in the simulated causal network
# @ - samples_data: samples with raw gene expression data
# @ - samples_data_iptg: samples with imputed gene expression data
#***************************************************************************************************
Univariate_Test2<-function(gene_index,samples_data,samples_data_iptg)
{
  outcome = samples_data[,dim(samples_data)[2]] # phenotype or outcome is the last column in this sample matrix
  univariate_test_Matrix = matrix(nrow = length(gene_index), ncol = 9)
  
  count = 1
  for(gene in gene_index)
  {
    print(gene)
    gene_rowdata = samples_data[,gene]
    gene_imputedata = samples_data_iptg[,gene]
    
    lm_gene_rowdata = lm(outcome~gene_rowdata)
    lm_gene_imputedata = lm(outcome~gene_imputedata)
    
    lm_gene_rowdata_pval = summary(lm_gene_rowdata)$coefficients[2,4]
    lm_gene_imputedata_pval = summary(lm_gene_imputedata)$coefficients[2,4]
    
    ###fyn. 2023.8.28
    sum_obj = summary(lm_gene_imputedata)
    imp_adjRsquare = sum_obj$adj.r.squared #"r.squared"
    imp_Rsquare = sum_obj$r.squared
    
    sum_obj_raw = summary(lm_gene_rowdata)
    raw_adj.r.squared = sum_obj_raw$adj.r.squared #"r.squared"
    raw_r.squared = sum_obj_raw$r.squared
    
    # univariate_test_Matrix[count,1] = gene # write gene_index into this column 
    univariate_test_Matrix[count,1] = count
    univariate_test_Matrix[count,2] = unname(coefficients(lm_gene_rowdata)[2])
    univariate_test_Matrix[count,3] = unname(coefficients(lm_gene_imputedata)[2])
    univariate_test_Matrix[count,4] = lm_gene_rowdata_pval
    univariate_test_Matrix[count,5] = lm_gene_imputedata_pval
    univariate_test_Matrix[count,6] = imp_adjRsquare
    univariate_test_Matrix[count,7] = imp_Rsquare
    univariate_test_Matrix[count,8] = raw_adj.r.squared
    univariate_test_Matrix[count,9] = raw_r.squared
    
    count = count + 1
  }
  
  univariate_test_Matrix = as.data.table(univariate_test_Matrix)
  colnames(univariate_test_Matrix) = c("Index_cnt","rawgene_coeff","impgene_coeff",
                                       "rawgene_pval","impgene_pval","imp_adjRsquare","imp_Rsquare",
                                       "raw_adj.r.squared","raw_r.squared")
  return(univariate_test_Matrix)
  
}




#************************************************************************************************
# Revised by yinly, Sep 26, 2023
# Description: gene-disease associations detection using commonly used methods like ordinary mutlivariate linear regression,LASSO, Elastic-net
#************************************************************************************************
# @gene_index: index of gene variables in our simulation
# @samples_data: the simulated data
# @samples_data_iptg: the simulated data("with "genes" replaced with "genotype"-predicted value")
# samples_data_iptg could be replaced by other data,e.g., raw data(samples_data)
#************************************************************************************************
Multivariate_linear_regression <- function(gene_index,samples_data,samples_data_iptg){
  outcome <- samples_data[,dim(samples_data)[2]] # phenotype or outcome is the last column in this sample matrix
  
  # multivariate linear regression on the imputed data
  MLR_mat <- matrix(nrow = length(gene_index), ncol = 5)
  gene_imputedata <- samples_data_iptg[,gene_index]
  mlr_obj <- lm(outcome~gene_imputedata)
  mlr_obj_coeffs <- summary(mlr_obj)$coefficients
  MLR_mat[,1] <- gene_index
  MLR_mat[,2:5] <- mlr_obj_coeffs[-1,]
  colnames(MLR_mat) <- c("Index_cnt",colnames(mlr_obj_coeffs))
  # output assoc index
  assoc_index <- which(MLR_mat[,5]<0.05)
  assoc_genes_mlr <- gene_index[assoc_index]
  stringent_assoc_index <- which(MLR_mat[,5]<0.001)
  stringent_assoc_genes_mlr <-gene_index[stringent_assoc_index]
  
  return(MLR_mat)
}

#************************************************************************************************
# @gene_index: index of gene variables in our simulation
# @samples_data_iptg: the simulated data("with "genes" replaced with "genotype"-predicted value")
# @alpha: The elasticnet mixing parameter(alpha=1 is the lasso penalty,alpha=0 is the ridge penalty)
# samples_data_iptg could be replaced by other data,e.g., raw data
#************************************************************************************************
library(glmnet)
mvlr_with_glmnet <- function(gene_index,samples_data,samples_data_iptg,alpha){
  outcome <- samples_data[,dim(samples_data)[2]] # phenotype or outcome is the last column in this sample matrix
  gene_imputedata <- samples_data_iptg[,gene_index]
  glmnet_mat <- matrix(nrow = length(gene_index), ncol = 5)
  glmnet_obj <- glmnet(gene_imputedata,outcome,family="mgaussian",alpha=alpha)
  glmnet_obj_beta <- glmnet_obj$beta
  glmnet_obj_beta_mat <- as.matrix(glmnet_obj_beta)
  # Here, we randomly selected a few lambdas, the smallest one is a must-pick
  glmnet_mat[,1] <- gene_index
  len <- ncol(glmnet_obj_beta_mat)
  lambdas <- glmnet_obj$lambda
  glmnet_mat[,2:5]<- glmnet_obj_beta_mat[,-(1:(len-4))]
  colnames(glmnet_mat) <- c("Index_cnt",lambdas[(len-3):len])
  
  return(glmnet_mat)
}


#************************************************************************************************
# @gene_index: index of gene variables in our simulation
# @samples_data_iptg: the simulated data("with "genes" replaced with "genotype"-predicted value")
# @alpha: The elasticnet mixing parameter(alpha=1 is the lasso penalty,alpha=0 is the ridge penalty)
# samples_data_iptg could be replaced by other data,e.g., raw data
# Note: this version choose the optimal parameters by cross validation
#************************************************************************************************
library(glmnet)
mvlr_with_glmnet2 <- function(gene_index,samples_data,samples_data_iptg,alpha){
  outcome <- samples_data[,dim(samples_data)[2]] # phenotype or outcome is the last column in this sample matrix
  gene_imputedata <- samples_data_iptg[,gene_index]
  glmnet_mat <- matrix(nrow = length(gene_index), ncol = 2)
  cv_glmnet <- cv.glmnet(gene_imputedata, outcome, alpha=alpha)
  lambda <- cv_glmnet$lambda.min
  glmnet_obj <- glmnet(gene_imputedata,outcome,family="mgaussian",alpha=alpha,lambda=lambda)
  glmnet_obj_beta <- as.vector(glmnet_obj$beta)
  #glmnet_obj_beta_mat <- as.matrix(glmnet_obj_beta)
  # Here, we only store the coefficient estimated from the given lambda(which is estimated from cross validation)
  glmnet_mat[,1] <- gene_index
  glmnet_mat[,2] <- glmnet_obj_beta
  coef_name <- paste0("Lambda_",lambda)
  colnames(glmnet_mat) <- c("Index_cnt",coef_name)
  
  return(glmnet_mat)
}


